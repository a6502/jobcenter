#!/usr/bin/env perl

use strict;
use warnings;
use 5.10.0;

# standard modules
use Data::Dumper;
use FindBin;

# non standard modules
use Config::Tiny;
use DBI;
use DBD::Pg qw(:async);
use Getopt::Long qw(GetOptionsFromArray);
use Time::Seconds;

use constant DEFAULT_LIMIT => 1000;
use constant RIGHT_ALIGN => {
	map { $_ => 1 } qw/
		duration
	/
};
use constant JOB_STATES => {
	map { $_ => 1 } qw/
		ready
		working
		sleeping
		done
		plotting
		zombie
		finished
		error
		eventwait
		childwait
		retrywait
		lockwait
	/
};

my $pgh;

exit main(@ARGV);

sub help {
	print <<__END;
usage:

    $FindBin::Script [options] job_ids

options:

    -h, --help      show this help message
    -d, --head      only show the head of the job tree
    -j, --job-id    return only the job_ids
    -a, --all       all jobs, including inactive jobs
    -s, --state     show jobs in states, comma seperated
    -x, --exclude   exclide jobs in states, comma seperated
    -l, --limit     default limit is ${\DEFAULT_LIMIT} jobs
__END
}

sub main {

	GetOptionsFromArray(\@_, \my %opts, 
		'help', 
		'head',
		'job-id',
		'all',
		'state=s',
		'exclude|x=s',
		'limit=i',
	) or die "unknown option";

	$opts{limit} //= DEFAULT_LIMIT;

	if ($opts{help}) {
		help();
		return 0;
	}

	die "bad limit: $opts{limit}\n" if $opts{limit} <= 0;

	$opts{state} //= '';
	$opts{state} =~ s/(?:^\s+\|\s+$)//g;

	my %states;

	for (split /\s*,\s*/, $opts{state}) {

		next if $_ eq '';

		my $state = lc($_);

		die "unknown state: $_\n" unless JOB_STATES->{$state};

		$states{$state}++;
	}

	$opts{exclude} //= '';
	$opts{exclude} =~ s/(?:^\s+\|\s+$)//g;

	my %exclude;

	for (split /\s*,\s*/, $opts{exclude}) {

		next if $_ eq '';

		my $state = lc($_);

		die "unknown state: $_\n" unless JOB_STATES->{$state};

		$exclude{$state}++;
	}

	$opts{state}   = \%states;
	$opts{exclude} = \%exclude;

	for (@_) {
		die "unknown job_id: $_\n" unless /^\d+$/;
	}

	my $cfgpath = "$FindBin::Bin/../etc/jobcenter.conf";

	my $cfg = Config::Tiny->read($cfgpath);
	die "failed to read config $cfgpath: ${\Config::Tiny->errstr}\n" unless $cfg;
	my $pgdsn = 'dbi:Pg:dbname=' . $cfg->{pg}->{db}
		. (($cfg->{pg}->{host}) ? ';host=' . $cfg->{pg}->{host} : '')
		. (($cfg->{pg}->{port}) ? ';port=' . $cfg->{pg}->{port} : '');
	my $pguser = $cfg->{admin}->{user};
	my $pgpass = $cfg->{admin}->{pass};

	# make our clientname the application_name visible in postgresql
	$ENV{'PGAPPNAME'} = "$0 [$$]";

	$pgh = DBI->connect(
		$pgdsn, $pguser, $pgpass,
		{
			AutoCommit => 1,
			RaiseError => 1,
			PrintError => 0,
		}
	) or die "cannot connect to db: $DBI::errstr";

	my $job_tree = job_tree(\%opts, \@_);

	if ($opts{head}) { 
		@$job_tree = grep { not defined $_->{parentjob_id} } @$job_tree 
	}

	if ($opts{'job-id'}) {
		for (sort { $a->{job_id} <=> $b->{job_id} } @$job_tree) {
			say $_->{job_id};
		}
	} else {
		table($job_tree);
	}

	return 0;
}

sub job_tree {
	my ($opts, $job_ids) = @_;

	my $job_qs     = join ',', ('?')x(@$job_ids);
	my $state_qs   = join ',', ('?')x(keys %{$opts->{state}});
	my $exclude_qs = join ',', ('?')x(keys %{$opts->{exclude}});

	my $sql = q[
		WITH recursive job_parents AS (
			SELECT 
				j.job_id,
				j.workflow_id,
				j.parentjob_id,
				array[j.job_id] found,
				j.job_id AS source,
				j.job_finished,
				j.state,
				EXTRACT(EPOCH FROM age(COALESCE(j.job_finished, now()), j.job_created)) duration
			FROM
				jobs j
			UNION ALL
			SELECT
				j.job_id,
				j.workflow_id,
				j.parentjob_id,
				jp.found || j.job_id found,
				jp.source,
				j.job_finished,
				j.state,
				EXTRACT(EPOCH FROM age(COALESCE(j.job_finished, now()), j.job_created)) duration
			FROM
				jobs j
			JOIN
				job_parents jp
			ON
				j.job_id = jp.parentjob_id AND
				j.job_id <> ALL (jp.found) -- loop guard
		), job_tree AS (
			SELECT 
				jp.job_id,
				jp.workflow_id,
				jp.parentjob_id,
				array[jp.job_id] found,
				jp.source AS source,
				jp.job_finished,
				jp.state,
				jp.duration
			FROM 
				job_parents jp
			UNION ALL
			SELECT 
				j.job_id, 
				j.workflow_id, 
				j.parentjob_id,
				jt.found || j.job_id found,
				jt.source,
				j.job_finished,
				j.state,
				EXTRACT(EPOCH FROM age(COALESCE(j.job_finished, now()), j.job_created)) duration
			FROM 
				jobs j 
			JOIN 
				job_tree jt 
			ON
				j.parentjob_id = jt.job_id AND
				j.job_id <> ALL (jt.found) -- loop guard
		)
	] . (!$opts->{all} ? qq[
		SELECT 
			jt.job_id,
			jt.workflow_id,
			jt.parentjob_id,
			jt.job_finished,
			jt.state,
			jt.duration,
			a.name
		FROM 
			job_tree jt
		LEFT JOIN
			actions a
		ON 
			jt.workflow_id = a.action_id
		WHERE 
			${\($exclude_qs ? qq[ jt.state NOT IN ($exclude_qs) AND ] : qq[])}
			${\($state_qs   ? qq[ jt.state IN ($state_qs) AND ]       : qq[])}
			${\($job_qs     ? qq[ jt.source IN ($job_qs) AND ]        : qq[])}
			jt.job_finished IS NULL
		GROUP BY
			jt.job_id,
			jt.workflow_id,
			jt.parentjob_id,
			jt.job_finished,
			jt.state,
			jt.duration,
			a.name
		ORDER BY 
			jt.job_id ASC
		LIMIT 
			$opts->{limit}
	] : qq[ 
		, job_all_parents AS (
			SELECT 
				*
			FROM 
				job_tree
			UNION ALL
			SELECT 
				ja.job_id, 
				ja.workflow_id, 
				ja.parentjob_id,
				jap.found || ja.job_id found,
				jap.source,
				ja.job_finished,
				ja.state,
				EXTRACT(EPOCH FROM age(COALESCE(ja.job_finished, now()), ja.job_created)) duration
			FROM 
				jobs_archive ja 
			JOIN 
				job_all_parents jap 
			ON 
				ja.job_id = jap.parentjob_id AND
				ja.job_id <> ALL (jap.found) -- loop guard
		), job_all_tree AS (
			SELECT 
				jap.job_id,
				jap.workflow_id,
				jap.parentjob_id,
				array[jap.job_id] found,
				jap.source AS source,
				jap.job_finished,
				jap.state,
				jap.duration
			FROM 
				job_all_parents jap
			UNION ALL
			SELECT 
				ja.job_id, 
				ja.workflow_id, 
				ja.parentjob_id,
				jat.found || ja.job_id found,
				jat.source,
				ja.job_finished,
				ja.state,
				EXTRACT(EPOCH FROM age(COALESCE(ja.job_finished, now()), ja.job_created)) duration
			FROM 
				jobs_archive ja 
			JOIN 
				job_all_tree jat 
			ON 
				ja.parentjob_id = jat.job_id AND
				ja.job_id <> ALL (jat.found) -- loop guard
		)
		SELECT 
			jat.job_id,
			jat.workflow_id,
			jat.parentjob_id,
			jat.job_finished,
			jat.state,
			jat.duration,
			a.name
		FROM 
			job_all_tree jat
		LEFT JOIN
			actions a
		ON 
			jat.workflow_id = a.action_id
		WHERE 
			${\($exclude_qs ? qq[ jat.state NOT IN ($exclude_qs) AND ] : qq[])}
			${\($state_qs   ? qq[ jat.state IN ($state_qs) AND ]       : qq[])}
			${\($job_qs     ? qq[ jat.source IN ($job_qs) AND ]        : qq[])}
			TRUE
		GROUP BY
			jat.job_id,
			jat.workflow_id,
			jat.parentjob_id,
			jat.job_finished,
			jat.state,
			jat.duration,
			a.name
		ORDER BY 
			jat.job_id ASC
		LIMIT 
			$opts->{limit}
	]);

	my $sth = $pgh->prepare_cached($sql);

	my $r = $sth->execute(keys %{$opts->{exclude}}, keys %{$opts->{state}}, @$job_ids);

	my @rows;
	while (my $row = $sth->fetchrow_hashref) {
		push @rows, {
			duration => format_duration($row->{duration}),
			map { $_ => $row->{$_} } 
			qw/
				job_id 
				parentjob_id 
				job_finished 
				state 
				name 
				workflow_id
			/
		};
	}


	return \@rows;
}

sub format_duration {
	my $t = Time::Seconds->new(shift);
	my $sign = '';
	if ($t < 0) {
		$t   *= -1;
		$sign = "- ";
	}
	my ($n, @d);
	for (
		[ONE_DAY,    'days',    'd'],
		[ONE_HOUR,   'hours',   'h'],
		[ONE_MINUTE, 'minutes', 'm'],
		[0,          'seconds', 's'],
	) {
		my ($one, $method, $unit) = @$_;
		if ($t >= $one) {
			$n = sprintf("%2d", $t->$method);
			push @d, "$n$unit";
			$t -= ($n * $one || 1); # XXX make sure seconds shown
		}
	}
	return $sign . join " ", @d;
}

sub table {
	my $job_tree = shift;

	my %relations; 
	my %jobs;
	my %heads;
	for (@$job_tree) {
		$relations{$_->{parentjob_id}//''}{$_->{job_id}}++;
		$jobs{$_->{job_id}} = $_;
		$heads{$_->{job_id}}++ unless defined $_->{parentjob_id};
	}

	my %headings = (
		job_id   => 'JOB_ID',
		duration => 'DURATION',
		state    => 'JOB_STATE',
		name     => 'WORKFLOW',
	);

	my %max;
	for my $row (\%headings, @$job_tree) {
		for (qw/job_id duration state/) {
			my $l = length $row->{$_};
			if (not defined $max{$_} or $l > $max{$_}) {
				$max{$_} = $l;
			}
		}
	}

	for (qw/job_id duration state name/) {
		if (my $m = $max{$_}) {
			if (RIGHT_ALIGN->{$_}) {
				printf "%${m}s  ", $headings{$_};
			} else {
				printf "%-${m}s  ", $headings{$_};
			}
		} else {
			print $headings{$_};
		}
	}

	print "\n";

	_table('', '', [ sort { $a <=> $b } keys %heads ], \%max, \%relations, \%jobs);
}

# recursive helper to output table
sub _table {
	my ($indent1, $indent2, $job_ids, $max, $relations, $jobs) = @_;

	for (my $i = 0; $i < @$job_ids; $i++) {

		my $job_id = $job_ids->[$i];

		my $top_level      = ($indent1 eq '' and $indent2 eq '');
		my $has_children   = $relations->{$job_id} ? 1 : 0;
		my $has_more_peers = ($i + 1 <= $#$job_ids);

		my $row = $jobs->{$job_id} or die "something went wrong!";

		for (qw/job_id duration state/) {

			if (my $m = $max->{$_}) {

				if (RIGHT_ALIGN->{$_}) {
					printf "%${m}s  ", $row->{$_};
				} else {
					printf "%-${m}s  ", $row->{$_};
				}
			}
		}

		print "$indent1$indent2$row->{name} ($row->{workflow_id})\n";

		my $indent3 = $indent1;

		if ($top_level) {
			$indent3 .= '';
		} elsif ($has_children and $has_more_peers) {
			$indent3 .= ' |  ';
		} else {
			$indent3 .= '    ';
		}

		if (my $children = $relations->{$job_id}) {

			my @children = ( sort { $a <=> $b } keys %$children );

			_table($indent3, ' \_ ', \@children, $max, $relations, $jobs);
		}
	}
}

